# Vue-lessons-2023

This template should help get you started developing with Vue 3 in Vite.

**Recommended IDE Setup:**  
[VSCode](https://code.visualstudio.com/) + [Volar](https://marketplace.visualstudio.com/items?itemName=Vue.volar) (and disable Vetur) + [TypeScript Vue Plugin (Volar)](https://marketplace.visualstudio.com/items?itemName=Vue.vscode-typescript-vue-plugin).
See [Vite Configuration Reference](https://vitejs.dev/config/).

## Початок

### Вступ

**Vue** - фреймворк для JS, створений для розробки користувацьких інтерфейсів. Працює на базі HTML, CSS, JS з можливістю декларативно програмувати користувацькі інтерфейси на основі компонентів.

**Способи використання Vue:**
\- розширення статичного HTML,  
\- вбудовування як веб-компонента в будь-яку сторінку,  
\- створення односторінкового додатку (SPA),  
\- фулстек / додаток з рендеронгом на стороні серверу (SSR),  
\- jamstack / генерація статичного додатку (SSG),  
\- створення десктопних, мобільних, WebGL додатків, навіть додатків для термінала.

У проектах Vue використовуються компоненти HTML-подібного формату Single-File Component (SFC, \*.vue). SFC інкапсулює логіку JS, шаблон HTML та стилі CSS в одному файлі.

Компоненти можна створювати в двох різних стилях API:  
**опційний API** побудовано навколо концепції "екземпляра компонента", краще узгоджуєтсья з розробкою на основі класу, більш зручний для початківців;  
**композиційний API** побудовано навколо концепції оголошення реактивних змінних безпосередньо в області функції, для складніших компонентів/випадків.

### Швидкий старт

Має бути встановлений Node.js >= 16.0.

1. `npm create vue@latest` - швидке розгортання vue проекта на базі vite (з опціями).
2. `cd projecName` - перехід до директорії з проектом.
3. `npm install` - встановити необхідні для роботи пакети.
4. `npm run dev` - компіляція та сервер з заміною для розробки.
5. `npm run build` - компіляція та упаковка для продакшена.

## Основи

### Створення додатку

Кожен додаток починається зі створення нового **екзкмпляру додатку** функцією `createApp()`.

```js
import { createApp } from "vue";
const app = createApp({});
```

Корневий компонент містить інші дочірні компоненти. При використанні Однофайлових компонентів зазвичай корневий компонент імпортується з іншого файлу.

```js
import { createApp } from "vue";
import App from "./App.vue";
const app = createApp(App);
```

Для рендеру екземпляра додатка необхідно викликати метод `.mount()`, приймає аргумент-контейнер, який може бути актуальним DOM-елементом або радком-селектором.

```js
app.mount("#app");
```

Вміст корневого компонента рендериться всередині контейнера, сам контейнер не є частиною додатка.  
Метод `.mount()` має бути викликаний після всіх налаштувань та реєстрації додаткових ресурсів.  
Шаблон корневого компонента зазвичай є частиною самого компонента, але може бути наданий окремо, написаний безпосередньо в контейнері для монтування.  
Екземпляр додатка надає доступ до об'єкта `.config`, що дозволяє налаштувати кілька параметрів на рівні додатка, а також забезпечує кілька методів реєстрації ресурсів.  
API `createApp` дозволяє декільком додаткам співіснувати на одній сторінці, кожен з яких має свою область конфігурації та глобальних ресурсів.

### Синтаксис шаблону

Інтерполяція тексту - найпростіша форма прив'язування даних `{{ msg }}`. Тег "вуса" буде замінений на значення переданої властивості (msg) з відповідного компонента екземпляра як текст.

Для введення html-коду використовується директива `v-html=""`. Вміст елемента з даною директивою буде замінений на значення переданої властивості, інтерпретованого як HTML.

Директива `v-bind:attr="dinamic"` наказує підтримувати синхронізацію атрибута елемента з переданою властивістю (при null та undefined видаляється). Скорочений вигляд `:attr="dinamic"`. Для динамічного прив'язування кількох атрибутів в директиву передається об'єкт з атрибутами `v-bind="attrObj"`, `const attrObj = {id: 'container', class: 'wrapper'}`

Всередині інтерполяції тексту та в значенні атрибута директив можна використовувати JS вирази, у виразі прив'язки можна викликати метод, відкритий для компонентів:

```js
{{ number + 1}}
{{ ok ? "Yes" : "No"}}
{{ message.split("").reverse().join("")}}
<div :id="`list-${id}`"></div>
<time :title="toTitleDate(date)" :datetime="date"> {{formatDate(date)}} </time>
```

**Директиви** - спеціальні атрибути з префіксом `v-`. Vue надає ряд вбудованих директив. Зазвичай очікуваним значенням директиви є окремі вирази JS. Їх завдання полягає в реактивному застосуванні оновлень до DOM при зміні значення виразу. Н-д `v-if` видаляє/вставляє елемент на основі правдивості значення виразу.  
Деякі директиви приймають **аргумент**, позначений двокрапкою: `v-bind:href="url"` аргумент _href_ прив'язує атрибут _href=""_ до значення виразу _url_.  
В аргументі директиви можна використовувати вираз JS, загорнувши його в квадратні дужки: `v-bind:[attrname]="url"`. В такому випадку значення null видалить прив'язку.  
Особливий спосіб зв'язки події позначають **модифікатори** - спеціальні постфікси, позначені крапкою (н-д v-on:submit.prevent="onSubmit" викличе event.preventDefault() для події).

### Основи реактивності

Рекомендований спосіб оголосити реактивний стан - функція `ref()`. Вона приймає аргумент і повертає його в об'єкті ref із властивістю `.value`:

```js
import { ref } from "vue";
const count = ref(0);
console.log(count.value); // 0
```

Для використання реактивного стану у шаблоні компонента потрібно оголосити його в функції setup() компонента. При цьому в шаблоні не потрібно додавати .value під час використання.

При використанні SFC можна спростити використання за допомогою `<script setup>`:

```js
<script setup>
	import { ref } from "vue";
	const count = ref(0)
	function increment() {count.value++}
</script>
<template>
	<button @click="increment"> {{ count }} </button>
</template>
```

Імпорт верхнього рівня, змінні та функції, оголошені в script setup, автоматично придатні для використання в шаблоні того самого компонента, як якби він був фукцією тієї ж області видимості.

Референції, навідміну від простих змінних, дають можливість реагувати на зміни стану і відразу ініціювати зміну компоненту (як через гетер та сетер).

Посилання можуть містити будь-які типи значень, у т.ч. глибоко вкладені об'єкти, масиви, вбудовані СД JS. Посилання зробить його глибоко реактивним, тобто зміни будуть виявлятись навіть для вкладених структур.

При зміні реактивного стану DOM оновлюється автоматично, але не синхронно. Vue буферизує змінні до наступного тіку в циклі оновлення для разового оновлення компонента незалежно від кількості змін. Дочекатись завершення оновлення можна за допомогою nextTick() Vue API.

