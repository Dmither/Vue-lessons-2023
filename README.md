# Vue-lessons-2023

This template should help get you started developing with Vue 3 in Vite.

**Recommended IDE Setup:**  
[VSCode](https://code.visualstudio.com/) + [Volar](https://marketplace.visualstudio.com/items?itemName=Vue.volar) (and disable Vetur) + [TypeScript Vue Plugin (Volar)](https://marketplace.visualstudio.com/items?itemName=Vue.vscode-typescript-vue-plugin).
See [Vite Configuration Reference](https://vitejs.dev/config/).

## Початок

### Вступ

**Vue** - фреймворк для JS, створений для розробки користувацьких інтерфейсів. Працює на базі HTML, CSS, JS з можливістю декларативно програмувати користувацькі інтерфейси на основі компонентів.

**Способи використання Vue:**
\- розширення статичного HTML,  
\- вбудовування як веб-компонента в будь-яку сторінку,  
\- створення односторінкового додатку (SPA),  
\- фулстек / додаток з рендеронгом на стороні серверу (SSR),  
\- jamstack / генерація статичного додатку (SSG),  
\- створення десктопних, мобільних, WebGL додатків, навіть додатків для термінала.

У проектах Vue використовуються компоненти HTML-подібного формату Single-File Component (SFC, \*.vue). SFC інкапсулює логіку JS, шаблон HTML та стилі CSS в одному файлі.

Компоненти можна створювати в двох різних стилях API:  
**опційний API** побудовано навколо концепції "екземпляра компонента", краще узгоджуєтсья з розробкою на основі класу, більш зручний для початківців;  
**композиційний API** побудовано навколо концепції оголошення реактивних змінних безпосередньо в області функції, для складніших компонентів/випадків.

### Швидкий старт

Має бути встановлений Node.js >= 16.0.

1. `npm create vue@latest` - швидке розгортання vue проекта на базі vite (з опціями).
2. `cd projecName` - перехід до директорії з проектом.
3. `npm install` - встановити необхідні для роботи пакети.
4. `npm run dev` - компіляція та сервер з заміною для розробки.
5. `npm run build` - компіляція та упаковка для продакшена.

## Основи

### Створення додатку

Кожен додаток починається зі створення нового **екзкмпляру додатку** функцією `createApp()`.

```js
import { createApp } from "vue";
const app = createApp({});
```

Корневий компонент містить інші дочірні компоненти. При використанні Однофайлових компонентів зазвичай корневий компонент імпортується з іншого файлу.

```js
import { createApp } from "vue";
import App from "./App.vue";
const app = createApp(App);
```

Для рендеру екземпляра додатка необхідно викликати метод `.mount()`, приймає аргумент-контейнер, який може бути актуальним DOM-елементом або радком-селектором.

```js
app.mount("#app");
```

Вміст корневого компонента рендериться всередині контейнера, сам контейнер не є частиною додатка.  
Метод `.mount()` має бути викликаний після всіх налаштувань та реєстрації додаткових ресурсів.  
Шаблон корневого компонента зазвичай є частиною самого компонента, але може бути наданий окремо, написаний безпосередньо в контейнері для монтування.  
Екземпляр додатка надає доступ до об'єкта `.config`, що дозволяє налаштувати кілька параметрів на рівні додатка, а також забезпечує кілька методів реєстрації ресурсів.  
API `createApp` дозволяє декільком додаткам співіснувати на одній сторінці, кожен з яких має свою область конфігурації та глобальних ресурсів.

### Синтаксис шаблону

Інтерполяція тексту - найпростіша форма прив'язування даних `{{ msg }}`. Тег "вуса" буде замінений на значення переданої властивості (msg) з відповідного компонента екземпляра як текст.

Для введення html-коду використовується директива `v-html=""`. Вміст елемента з даною директивою буде замінений на значення переданої властивості, інтерпретованого як HTML.

Директива `v-bind:attr="dinamic"` наказує підтримувати синхронізацію атрибута елемента з переданою властивістю (при null та undefined видаляється). Скорочений вигляд `:attr="dinamic"`. Для динамічного прив'язування кількох атрибутів в директиву передається об'єкт з атрибутами `v-bind="attrObj"`, `const attrObj = {id: 'container', class: 'wrapper'}`

Всередині інтерполяції тексту та в значенні атрибута директив можна використовувати JS вирази, у виразі прив'язки можна викликати метод, відкритий для компонентів:

```js
{{ number + 1}}
{{ ok ? "Yes" : "No"}}
{{ message.split("").reverse().join("")}}
<div :id="`list-${id}`"></div>
<time :title="toTitleDate(date)" :datetime="date"> {{formatDate(date)}} </time>
```

**Директиви** - спеціальні атрибути з префіксом `v-`. Vue надає ряд вбудованих директив. Зазвичай очікуваним значенням директиви є окремі вирази JS. Їх завдання полягає в реактивному застосуванні оновлень до DOM при зміні значення виразу. Н-д `v-if` видаляє/вставляє елемент на основі правдивості значення виразу.  
Деякі директиви приймають **аргумент**, позначений двокрапкою: `v-bind:href="url"` аргумент _href_ прив'язує атрибут _href=""_ до значення виразу _url_.  
В аргументі директиви можна використовувати вираз JS, загорнувши його в квадратні дужки: `v-bind:[attrname]="url"`. В такому випадку значення null видалить прив'язку.  
Особливий спосіб зв'язки події позначають **модифікатори** - спеціальні постфікси, позначені крапкою (н-д v-on:submit.prevent="onSubmit" викличе event.preventDefault() для події).

### Основи реактивності

Рекомендований спосіб оголосити реактивний стан - функція `ref()`. Вона приймає аргумент і повертає його в об'єкті ref із властивістю `.value`:

```js
import { ref } from "vue";
const count = ref(0);
console.log(count.value); // 0
```

Для використання реактивного стану у шаблоні компонента потрібно оголосити його в функції setup() компонента. При цьому в шаблоні не потрібно додавати .value під час використання.

При використанні SFC можна спростити використання за допомогою `<script setup>`:

```js
<script setup>
	import { ref } from "vue";
	const count = ref(0)
	function increment() {count.value++}
</script>
<template>
	<button @click="increment"> {{ count }} </button>
</template>
```

Імпорт верхнього рівня, змінні та функції, оголошені в script setup, автоматично придатні для використання в шаблоні того самого компонента, як якби він був фукцією тієї ж області видимості.

Референції, навідміну від простих змінних, дають можливість реагувати на зміни стану і відразу ініціювати зміну компоненту (як через гетер та сетер).

Посилання можуть містити будь-які типи значень, у т.ч. глибоко вкладені об'єкти, масиви, вбудовані СД JS. Посилання зробить його глибоко реактивним, тобто зміни будуть виявлятись навіть для вкладених структур.

При зміні реактивного стану DOM оновлюється автоматично, але не синхронно. Vue буферизує змінні до наступного тіку в циклі оновлення для разового оновлення компонента незалежно від кількості змін. Дочекатись завершення оновлення можна за допомогою nextTick() Vue API.

Інший спосіб оголосити реактивний стан - функція `reactive()`, робить сам об'єкт реактивним.

```js
<script setup>
	import { reactive } from 'vue';
	const state = reactive({ count: 0 });
</script>
<template>
	<button @click="state.count++">{{ state.count }}</button>
</template>
```

Реактивні об'єкти є Proxy, поводяться так само як звичайні об'єкти, але Vue здатний перехоплювати доступ і мутацію всіх властивостей реактивного об'єкта. 

Ф-я reactive() глибоко перетворює об'єкт, вкладені об'єкти також загортаються. Він також внутрішньо викликається ref(), якщо значення є об'єктом. Для відмови від глибокої реактивності використовується `shallowReactive()`.

Реактивним є лише проксі - зміна оригінального об'єкта не призведе до оновлення. Бажано використовувати виключно проксі-версії стану. Виклик reactive() для одного об'єкта або його проксі повертає той самий проксі. Через глибоку реактивність вкладені об'єкти - також проксі.

API `reactive()` працює лише для об'єктів, вимагає збереження посилання на реактивний об'єкт, не підтримує деструктурування. Так рекомендованим методом є `ref()`.

### Обчислювальні властивості

Вбудовані в шаблони вирази досить зручні для простих разових дій. Більш складні дії з великою кількістю логічних операцій краще обробляти за допомогою **обчислювальних властивостей**. Ф-я `computed()` повертає обчислювальну референцію. Доступ до обчислювального результату через `.value`, автоматично розпаковується всередині шаблона. Обчислювальна властивість автоматично відстежує свої реактивні залежності.

```js
<script setup>
	import { reactive, computed } from 'vue';
	const author = reactive({
		name: "John",
		books: ["BookName1", "BookName2"]
	})
	const publishedBooksMessage = computed(() => author.books.length > 0 ? "Yes" : "No")
	function getMessage() {return publishedBooksMessage.value}
</script>
<template>
	<p>Has published books: <span> {{ publishedBooksMessage }}</span></p>
</template>
```

Навідміну від метода для обчислення значення, обчислювальні властивості кешуються на основі їх реактивних залежностей і перераховуються лише при їх зміні.

Якщо обчислювальна властивість має бути записувана, їй явно прописується геттер і сеттер.

```js
const firstName = ref("John");
const lastName = ref("Doe");
const fullName = computed({
	get() {
		return firstName.value + " " + lastname.value;
	},
	set(newValue) {
		[firstName.value, lastName.value] = newValue.split(" ");
	}
})
```

Обчислювальні геттери мають бути без побічних ефектів, лише для обчислення та повернення значення на основі інших. Краще уникати сеттерів.

### Прив'язування класів та стилів

Оскільки `class` та `style` - атрибути, використовуються разом з `v-bind`, окрім рядків можуть бути обчислені як об'єкти або масиви.

```html
<div :class="{ active: isActive }"></div>
Клас "active" буде автоматично призначений при (isActive === true)

<div class="static" :class="{ active: isActive, 'text-danger': hasError }"></div>
Також можна визначити декілька класів як поля в об'єкті, разом зі звичайним класом

<div :class="classObject"></div>
Замість визначення напряму в шаблоні може бути переданий визначений реактивний клас

<div :class="[activeClass, errorClass]"></div>
Значення класів може бути передано масивами
```

Поширена і потужна модель - прив'язувати обчислювальні властивості, які повертають об'єкт:

```js
const isActive = ref(true)
const error = ref(null)
const classObject = computed(() => ({
	active: isActive.value && !error.value
}))
```

Прив'язування вбудованих стилів до об'єктних значень JS підтримує `:style` (узгоджено з властивістю style). Рекомендовано використовувати camelCase, підтримуються ключі і в kebab-case. Прив'язування до об'єкта стилю допомагає підтримувати шаблон чистішим. Прив'язування до масивів дозволить додати декілька об'єктів стилів. Префікси автоматично додаються Vue за потреби. Множинні значення (з префіксами) будуть використовувати останнє підтримуване браузером.

```html
<div :style="{ fontSize: fontSize + 'px', 'font-family': fontFamily }"></div>
<div :style="styleObject"></div>
<div :style="[baseStyles, overridingStyles]"></div>
<div :style="{ display: ['-webkit-box', '-ms-flexbox', 'flex'] }"></div>
```

### Умовний рендеринг

Директива `v-if` дозволяє згенерувати блок дише при правдивому значенні, `v-else` та `v-else-if` доповнюють умовну логіку:
```html
<div v-if="type === 'A'">Type A</div>
<div v-else-if="type === 'B'">Type B</div>
<div v-else>Unknown</div>
Виводиться лише один блок відповідно до значення змінної
```

Директиви `v-if`, `v-else-if`, `v-else` можуть бути застосований до всього шаблону в елементі `<template>`. Фінальний результат рендеру не містить `<template>`.

Іншу можливість умовного показу надає директива `v-show` з аналогічним використанням. Не підтримується елементом template, не працює з v-else.

Навідміну від v-if, v-show лише перемикає властивість display, елемент завжди згенерований і лишається в DOM.

`v-if` впливає на "справжній" рендеринг, під час перемикання забезпечує належне видалення та створення слухачів подій та дочірніх елементів. При неправдивій умові на початку рендеринга не генерує блок до настання правдивості. `v-else` завжди згенерований попри початкову умову. `v-if` має вищу вартість при перемиканні, `v-show` - при початковому рендерингу.

### Рендеринг списків

