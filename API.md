# API

## Глобальний API

### Додаток

`createApp()` створює екземпляр додатку; перший аргумент - кореневий компонент, другий (необов'язковий) - реквізити, необхідні корневому компоненту.  
`createSSRApp()` створює додаток в режимі гідратації SSR; використання як createApp().  
`app.mount()` монтує екземпляр додатка в елемент-контейнер; аргумент - фактичний елемент DOM або селектор, повертає екземпляр корневого компонента.  
`app.unmount()` демонтує змонтований екземпляр додатка з хуками життєвого циклу демонтування.  
`app.component()` реєструє глобальний компонент, якщо передано ім'я і визначення компонента, або отримує вже зареєстрований, якщо передано лише ім'я.  
`app.directive()` реєструє глобальну користувацьку директиву (ім'я і визначення директиви) або отримує вже зареєстровану (ім'я).  
`app.use()` встановлює плагін; перший аргумент - плагін, другий - додаткові параметри.  
`app.provide()` надає значення, яке можна додати до всіх компонентів-нащадків додатка.  
`app.runWithContext()` виконує колбек з поточним додатком як контекстом ін'єкції.  
`app.version` надає версію Vue, у якій було створено додаток.  
`app.config` об'єкт конфігурації додатка; можна змінити перед монтуванням.  
`app.config.errorHandler` призначає глобальний обробник для неперехоплених помилок додатка.  
`app.config.warnHandler` призначає користувацький обробник для попереджень Vue.  
`app.config.performance` bool; увімкнення роботи з devtool браузера (в режимі розробки)_.  
`app.config.compilerOptions` налаштовує параметри компілятора під час виконання_.  
`app.config.globalProperties` об'єкт для реєстрації глобальних властивостей*.  
`app.config.optionMargeStrategies` визначення стратегій об'єднання користувацьких параметрів*.

### Загальне

`version` показує поточну версію Vue.  
`nextTick()` очікування наступного оновлення DOM.  
`defineComponent()` визначення компонента за допомогою визначення типу.  
`defineAsyncComponent()` визначає асинхронний компонент, завантажується лише під час рендерингу.  
`defineCustomElement()` повертає рідний конструктор класу користувацького елемента.

## Композиційний API

### setup()

Хук `setup()` служить точкою входу для Композиційного API у компонентах при:  
\- використанні Композиційного API без етапу збірки;  
\- інтеграція коду Композиційного API а Опційний.  
При використанні Композиційного API з SFC рекомендовано використовувати `<script setup>`.  
Оголошений реактивний стан, повернутий в setup(), доступний в шаблоні.  
Референції, повернуті в setup, неглибоко розгортаються, тому не потребують `.value`.  
Першим аргументом setup() є `props`, який в setup є реактивним (без деструктуризації);  
другим - об'єкт контексту, який надає інші корисні значення, може бути деструктурований.

```js
export default {
	props: {
		title: String,
	},
	setup(props, context) {
		console.log(props.title);
		console.log(context.attrs);
		const count = ref(0);
		return { count };
	},
	mounted() {
		console.log(this.count);
	},
};
```

Використання з функціями рендерингу

### Реактивність: основи

`ref()` приймає внутрішнє значення, повертає змінний реактивний об'єкт-референцію.  
`shallowRef()` повертає референцію без глибокого перетворення.  
`computed()` приймає геттер-функцію, повертає реактивний об'єкт-референцію лише для читання, або об'єкт з геттером і сеттером, повертає референцію з можливістю запису.  
`reactive()` приймає об'єкт (і похідні), повертає реактивний проксі об'єкта.  
`shallowReactive()` повертає проксі без глибокого перетворення.  
`readOnly()` приймає об'єкт або референцію, повертає проксі лише для читання оригіналу.  
`watchEffect()` приймає ф-ю ефекту, запускає негайно і повторно при зміні залежностей. Другий необов'язковий аргумент - опції налаштування часу спрацювання і налагодження залежностей.  
`watchPostEffect()` псевдонім watchEffect() з параметром flush: "post".  
`watchSyncEffect()` псевдонім watchEffect() з параметром flush: "sync".  
`watch()` спостерігає за одним або кількома реактивними джерелами, викликає колбек при їх зміні.

### Реактивність: утиліти

`isRef()` перевіряє, чи значення є об'єкт-референція.  
`unref()` функція-обгортка для val = isRef(val) ? val.value : val.  
`toRef()` нормалізає значення, референції, геттери до референцій.  
`toValue()` нормалізує значення, референції, геттери до значень.  
`toRefs()` перетворює реактивний об'єкт у звичайний, де кожна властивість є референцією.  
`isProxy()` перевіряє, чи є об'єкт проксі, створений reactive(), readonly() та shallow-.  
`isReactive()` перевіряє, чи є об'єкт проксі, створений reactive() або shallowReactive().  
`isReadonly()` перевіряє, чи є об'єкт проксі, створений readonly(), shallow- або computed без set.

### Реактивність: розширено

`shallowRef()` неглибока версія ref(), реактивна лише змінна value.  
`triggerRef()` примусове ініціювання ефектів, які залежать від shallowRef.  
`customRef()` створює референцію з можливістю явно контролювати відстеження залежностей.  
`shallowReactive()` неглибока версія reactive().  
`shallowReadonly()` неглибока версія readonly().  
`toRaw()` повертає необроблений оригінальний об'єкт із Vue proxy.  
`markRaw()` позначає об'єкт, щоб він ніколи не був перетворений на проксі.  
`effectScope()` створює об'єкт області дії ефекту, який може захоплювати інші реактивні ефекти, ствоерні всередині нього, для можливості знищення всіх разом.  
`getCurrentScope()` повертає поточну активну область дії ефекту при наявності.  
`onScopeDispose()` раєстрація колбеку для активної області дії ефекту.

### Хуки життєвого циклу

Всі функції хуків життєвого циклу реєструють колбек, який викликається за певних умов:  
`onMounted()` після монтування компонента;  
`onUpdated()` після оновлення компонентом свого DOM;  
`onUnmounted()` після демонтування об'єкта;  
`onBeforeMount()` перед монтуванням (песля завершення налаштування реактивного стану);  
`onBeforeUpdate()` перед оновленням DOM через реактивну зміну стану;  
`onBeforeUnmount()` перед демонтуванням;  
`onErrorCaptured()` коли виявлено помилку, що поширюється від компонента-нащадка;  
`onRenderTracked()` dev only, коли залежність відстежується ефектом рендерингу компонента;  
`onRenderTriggered()` dev only, коли залежність ініціює повторний запуск ефекту рендерингу;  
`onActivated()` після вставки екземпляра в DOM як частину, кешовану KeepAlive;  
`onDeactivated()` після видалення відповідного екземпляра;  
`onServerPrefetch()` SSR only, перед рендерингом екземпляра компонента на сервері.

### Ін'єкція залежностей

`provide()` надає значення, яке може бути встановлено компонентам-нащадкам.  
`inject()` вводить значення, надане батьківським компонентом або застосунком.